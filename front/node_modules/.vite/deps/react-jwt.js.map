{
  "version": 3,
  "sources": ["../../react-jwt/src/helpers/base64.ts", "../../react-jwt/src/jwt/index.ts", "../../react-jwt/src/hooks/index.tsx"],
  "sourcesContent": ["const map = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nconst reverseMap = new Map();\n\nfor (let i = 0; i < map.length; i++) {\n  let bits: string = i.toString(2);\n  const padding: number = 6 - bits.length;\n  bits = \"0\".repeat(padding) + bits;\n\n  reverseMap.set(map.charCodeAt(i), bits);\n}\n\n/**\n * Convert base64 string to an array of bytes\n * @param base64Str - Base64 string\n * @returns Array of 1-byte elements\n */\nfunction toByteArray(base64Str: string): string[] {\n  let bits: string = \"\";\n\n  // convert base64 string to bits\n  for (let i = 0; i < base64Str.length; i++) {\n    bits += reverseMap.get(base64Str.charCodeAt(i));\n  }\n\n  // Remove padding (\"=\" characters)\n  bits = bits.slice(0, bits.length - (bits.length % 8));\n\n  const bytesArray = [];\n\n  // Separate string by 8-bit groups\n  for (let i = 0; i < bits.length / 8; i++) {\n    bytesArray.push(bits.slice(i * 8, i * 8 + 8));\n  }\n\n  return bytesArray;\n}\n\n/**\n * Convert a base64 string to an UTF-8 array\n * @param base64Str - Base64 string\n * @returns UTF-8 array\n */\nexport function base64DecToArray(base64Str: string): number[] {\n  // Replace - _ and remove padding\n  base64Str = base64Str.replaceAll(\"=\", \"\");\n  base64Str = base64Str.replaceAll(\"-\", \"+\");\n  base64Str = base64Str.replaceAll(\"_\", \"/\");\n\n  const charCodes: string[] = toByteArray(base64Str);\n\n  return charCodes.map((code) => parseInt(code, 2));\n}\n\n/**\n * Convert a UTF-8 array to string\n * @param bytes\n * @returns Decoded string\n */\nexport function UTF8ArrToStr(bytes: number[]): string {\n  let decoded: string = \"\"; // Decoded string\n  let nPart: number;\n  const arrayLength: number = bytes.length;\n\n  for (let i = 0; i < arrayLength; i++) {\n    nPart = bytes[i];\n    decoded += String.fromCodePoint(\n      nPart > 251 && nPart < 254 && i + 5 < arrayLength /* six bytes */\n        ? /* (nPart - 252 << 30) may be not so safe in ECMAScript! So... */\n          (nPart - 252) * 1073741824 +\n            ((bytes[++i] - 128) << 24) +\n            ((bytes[++i] - 128) << 18) +\n            ((bytes[++i] - 128) << 12) +\n            ((bytes[++i] - 128) << 6) +\n            bytes[++i] -\n            128\n        : nPart > 247 && nPart < 252 && i + 4 < arrayLength /* five bytes */\n        ? ((nPart - 248) << 24) +\n          ((bytes[++i] - 128) << 18) +\n          ((bytes[++i] - 128) << 12) +\n          ((bytes[++i] - 128) << 6) +\n          bytes[++i] -\n          128\n        : nPart > 239 && nPart < 248 && i + 3 < arrayLength /* four bytes */\n        ? ((nPart - 240) << 18) +\n          ((bytes[++i] - 128) << 12) +\n          ((bytes[++i] - 128) << 6) +\n          bytes[++i] -\n          128\n        : nPart > 223 && nPart < 240 && i + 2 < arrayLength /* three bytes */\n        ? ((nPart - 224) << 12) + ((bytes[++i] - 128) << 6) + bytes[++i] - 128\n        : nPart > 191 && nPart < 224 && i + 1 < arrayLength /* two bytes */\n        ? ((nPart - 192) << 6) + bytes[++i] - 128 /* nPart < 127 ? */\n        : /* one byte */\n          nPart\n    );\n  }\n\n  return decoded;\n}\n", "import { base64DecToArray, UTF8ArrToStr } from \"../helpers/base64\";\n\n/**\n * Try to decode a JWT. If the token is valid you'll get an object otherwise you'll get null\n * @param token - The JWT that you want to decode\n * @returns Decoded token\n */\nexport function decodeToken<T>(token: string): T | null;\nexport function decodeToken(token: string): Object | null;\nexport function decodeToken<T = Object>(token: string): T | null {\n  try {\n    // if the token has more or less than 3 parts or is not a string\n    // then is not a valid token\n    if (token.split(\".\").length !== 3 || typeof token !== \"string\") {\n      return null;\n    }\n\n    // payload ( index 1 ) has the data stored and\n    // data about the expiration time\n    const payload: string = token.split(\".\")[1];\n\n    const base64Bytes: number[] = base64DecToArray(payload);\n    // Convert utf-8 array to string\n    const jsonPayload: string = decodeURIComponent(UTF8ArrToStr(base64Bytes));\n    // Parse JSON\n    return JSON.parse(jsonPayload);\n  } catch (error) {\n    console.error(\"There was an error decoding token: \", error);\n    // Return null if something goes wrong\n    return null;\n  }\n}\n\n/**\n * Verify if the token is expired or not\n * @param token - Your JWT\n * @returns boolean\n */\nexport function isTokenExpired(token: string): boolean {\n  const decodedToken: any = decodeToken(token);\n  let result: boolean = true;\n\n  if (decodedToken && decodedToken.exp) {\n    const expirationDate: Date = new Date(0);\n    expirationDate.setUTCSeconds(decodedToken.exp); // sets the expiration seconds\n    // compare the expiration time and the current time\n    result = expirationDate.valueOf() < new Date().valueOf();\n  }\n\n  return result;\n}\n", "import { useState, useEffect } from \"react\";\nimport { decodeToken, isTokenExpired } from \"../jwt\";\n\n/**\n * This function will help you to decode a JWT and know if it's expired or not\n * @param userJwt - Your JWT\n * @returns An object containing the properties isExpired, decodedToken and reEvaluateToken\n */\nexport function useJwt<T>(userJwt: string): IUseJwt<T>;\nexport function useJwt(userJwt: string): IUseJwt;\nexport function useJwt<T>(userJwt: string): IUseJwt<T> {\n  const [isExpired, setIsExpired] = useState<boolean>(false);\n  const [decodedToken, setDecodedToken] = useState<T | null>(null);\n\n  useEffect(() => {\n    evaluateToken(userJwt);\n  }, [userJwt]);\n\n  const evaluateToken = (token: string) => {\n    setDecodedToken(decodeToken<T>(token));\n    setIsExpired(isTokenExpired(token));\n  };\n\n  return { isExpired, decodedToken, reEvaluateToken: evaluateToken };\n}\n\ninterface IUseJwt<T = Object> {\n  isExpired: boolean;\n  decodedToken: T | null;\n  reEvaluateToken: (token: string) => void;\n}\n"],
  "mappings": "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",
  "names": ["map", "reverseMap", "Map", "i", "length", "bits", "toString", "padding", "repeat", "set", "charCodeAt", "toByteArray", "base64Str", "get", "slice", "bytesArray", "push", "base64DecToArray", "replaceAll", "charCodes", "code", "parseInt", "UTF8ArrToStr", "bytes", "decoded", "nPart", "arrayLength", "String", "fromCodePoint", "decodeToken", "token", "split", "payload", "base64Bytes", "jsonPayload", "decodeURIComponent", "JSON", "parse", "error", "console", "isTokenExpired", "decodedToken", "result", "exp", "expirationDate", "Date", "setUTCSeconds", "valueOf", "useJwt", "userJwt", "useState", "isExpired", "setIsExpired", "setDecodedToken", "useEffect", "evaluateToken", "reEvaluateToken"]
}
